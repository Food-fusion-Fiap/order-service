name: Go CI/CD

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - main
  push:
    branches:
      - main

permissions:
  contents: write

jobs:
  ci:
    name: CI Pipeline
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set up Go
        uses: actions/setup-go@v2
        with:
          go-version: ^1.22.2

      - name: Install dependencies
        run: go mod download

      - name: Build
        run: go build -o ./app .

      - name: Run unit Tests
        run: |
          go test -coverprofile=./cov.out ./...

      - name: Analyze with SonarCloud

        # You can pin the exact commit or the version.
        # uses: SonarSource/sonarcloud-github-action@v2.2.0
        uses: SonarSource/sonarcloud-github-action@4006f663ecaf1f8093e8e4abb9227f6041f52216
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}   # Generate a token on Sonarcloud.io, add it to the secrets of this repo with the name SONAR_TOKEN (Settings > Secrets > Actions > add new repository secret)
        with:
          # Additional arguments for the SonarScanner CLI
          args:
            # Unique keys of your project and organization. You can find them in SonarCloud > Information (bottom-left menu)
            # mandatory
            -Dsonar.projectKey=Food-fusion-Fiap_order-service
            -Dsonar.organization=food-fusion-fiap
            -Dsonar.tests=.
            -Dsonar.test.inclusions=**/*_test.go
            -Dsonar.sources=src/
            -Dsonar.exclusions=src/infra/db/**,src/infra/web/routes/**,src/infra/web/http-clients/**,src/adapters/controllers/order/**,src/adapters/controllers/product/**,src/adapters/gateways/**,src/core/domain/usecases/utils/**
            -Dsonar.go.coverage.reportPaths=cov.out
            # Comma-separated paths to directories containing main source files.
            #-Dsonar.sources= # optional, default is project base directory
            # Comma-separated paths to directories containing test source files.
            #-Dsonar.tests= # optional. For more info about Code Coverage, please refer to https://docs.sonarcloud.io/enriching/test-coverage/overview/
          # Adds more detail to both client and server-side analysis logs, activating DEBUG mode for the scanner, and adding client-side environment variables and system properties to the server-side log of analysis report processing.
          #-Dsonar.verbose= # optional, default is false
          # When you need the analysis to take place in a directory other than the one from which it was launched, default is .
          projectBaseDir: .

  build-and-deploy:
    name: Continuous Delivery Pipeline
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1

      - name: Set up AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v1

      - name: Calculate next tag
        id: tagger
        run: |
          TAG="0.1.0"  # Initialize with the starting version
          LATEST_TAG=$(git tag --sort=-v:refname | head -n 1)
          if [ ! -z "$LATEST_TAG" ]; then
            TAG=$(echo $LATEST_TAG | awk -F. '{$NF+=1; OFS="."; print $0}')
          fi
          echo "Next tag: $TAG"
          echo "::set-output name=next_tag::$TAG"

      - name: Build, tag, and push Docker image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ steps.tagger.outputs.next_tag }}
        run: |
          IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          docker build -t $IMAGE_URI .
          docker push $IMAGE_URI
          echo "IMAGE_URI=$IMAGE_URI" >> $GITHUB_ENV

      - name: Update Kubernetes configuration
        run: |
          sed -i 's|placeholder_repository_name|'"$IMAGE_URI"'|' ./infra/golang-app-deployment.yaml
          cat ./infra/golang-app-deployment.yaml

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -sSL https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Update kube config
        run: aws eks update-kubeconfig --name ${{ secrets.AWS_EKS_CLUSTER_NAME }} --region ${{ secrets.AWS_REGION }}

      - name: Deploy to Kubernetes
        env:
          K8S_DEPLOYMENT_NAME: ${{ secrets.K8S_DEPLOYMENT_NAME }}
        run: |
          kubectl apply -f ./infra
          kubectl rollout status deployment/$K8S_DEPLOYMENT_NAME

      - name: Deploy to Kubernetes
        env:
          ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ github.sha }}
          K8S_DEPLOYMENT_NAME: ${{ secrets.K8S_DEPLOYMENT_NAME }}
          K8S_DEPLOYMENT_CONTAINER_NAME: ${{ secrets.K8S_DEPLOYMENT_CONTAINER_NAME }}
        run: |
          kubectl set image deployment/$K8S_DEPLOYMENT_NAME $K8S_DEPLOYMENT_CONTAINER_NAME=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG --record
          kubectl rollout status deployment/$K8S_DEPLOYMENT_NAME

#      - name: Bump version and push tag
#        id: tag_version
#        uses: mathieudutour/github-tag-action@v6.2
#        with:
#          github_token: ${{ secrets.GITHUB_TOKEN }}